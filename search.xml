<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="//%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>//%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>整数二分：<br>有单调性一定可以二分，可以二分的题目不一定非得有单调性</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="//C++%E7%AE%97%E6%B3%95%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%80%9F%E6%88%90/"/>
      <url>//C++%E7%AE%97%E6%B3%95%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%80%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h1 id="C-算法蓝桥杯速成"><a href="#C-算法蓝桥杯速成" class="headerlink" title="C++算法蓝桥杯速成"></a>C++算法蓝桥杯速成</h1><h2 id="1-万能头"><a href="#1-万能头" class="headerlink" title="1.万能头"></a>1.万能头</h2><p><strong>#include  &lt;bits&#x2F;stdc++.h&gt;</strong></p><blockquote><p>&lt;bits&#x2F;stdc++.h&gt;它是一个特殊的头文件，包含了大部分标准 C和C++ 库的头文件，可以方便地一次性引入多个库，简化代码编写过程。对于C++而言，在这个头文件中，通常包含的标准库包括：<br><iostream>：用于输入输出操作。<br><vector>：提供动态数组（向量）的实现。<br><string>：处理字符串操作。<br><algorithm>：包含各种算法，如排序、搜索等。<br><cmath>：包含数学函数，如数值计算、三角函数等。<br><queue>：实现队列（先进先出）数据结构。<br><stack>：实现栈（后进先出）数据结构。</p><p>等等</p></blockquote><h2 id="2-Bool"><a href="#2-Bool" class="headerlink" title="2.Bool"></a>2.Bool</h2><p>用bool的原因：用bool可以明确表示条件的逻辑状态</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="//4.12%E6%9C%89%E6%84%9F/"/>
      <url>//4.12%E6%9C%89%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="4-12有感"><a href="#4-12有感" class="headerlink" title="4.12有感"></a>4.12有感</h1><p>今天和卓兄交谈后 收获不少 人生真的很多时候就是和机器学习一样 我们喂入不同的数据 有时候输出的就是相同的结果 有些模型就是如此 你又怎么去改变他呢</p><p>这件事情差不多你也可以放下了 这个社会很险恶 这个道理你要懂 有时候这个谈恋爱真的和选导师是一样的 哈哈哈哈哈 有点不可信吧 卓哥确实驳倒了我的那个结论 你说什么谈一人终一生 这只是在你假想了一个很适合你的人 其实真的现在发现谈恋爱这个东西是真的需要经验的 你要懂得怎么去谈 在谈的途中守护好这个女孩</p><p>当然，这都是后话，大一就想着好好学习就好了，我觉得，好好提升自己，没有什么利益关系的东西不需要在乎，在乎这么多干嘛都是小事，兄弟，好好提升自己才是正道。</p><p>好好想着怎么发论文 好好想着怎么搞好绩点 好好想着怎么提高技术 这才是硬道理</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="//hello-world/"/>
      <url>//hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>3月反思</title>
      <link href="//3%E6%9C%88%E5%8F%8D%E6%80%9D/"/>
      <url>//3%E6%9C%88%E5%8F%8D%E6%80%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="3月反思"><a href="#3月反思" class="headerlink" title="3月反思"></a>3月反思</h1><p>3月已经过去了，这个月也算学了不少东西吧，前端知识，一丢丢算法知识，transformer底层架构，搭建pytorch环境…现在很多想不起来了，但说实话也算有点摆烂了，并没有像学长那么勤快。大学你要真的有所成绩，其实大家都是没有周六周日的，这个事情你要清楚。</p><p>今天是31号 刚和鹏哥聊了很久，其实说到底能力最重要，现在的实力比当年他们那一届差远了，</p><p>我目前能做的就是不断挤时间，全部兼得，特别是我想做科研。其实大家很苦，不管是说yx学姐还是zp学长还有等等很多优秀学长学姐，他们都是不断努力才拥有现在的成果的</p><p><img src="C:\Users\QuCheng\AppData\Roaming\Typora\typora-user-images\image-20250331235518233.png" alt="image-20250331235518233"></p><p>我问过他的建议，比赛还是多参加，因为现在对我来说困难是因为不够熟练，熟练了可能就是几天的事情了，像他们造一个作品可能就是半天的时间</p><p>我提了一个问题：“现在主要项目都是他在做 我们做的工作感觉就和你上面说的技术搭架好像关系没有特别大” </p><p>Answer:”因为时间比较赶 你们只能做这种活，你们只能比完赛再去自己研究  都是这样过来的</p><p><img src="C:\Users\QuCheng\AppData\Roaming\Typora\typora-user-images\image-20250331235924188.png" alt="image-20250331235924188"></p><p>我觉得现在就是不断学 瞄准目标 哪有这么多睡意 只不过是自己懒惰的借口罢了 加油吧 无暗 我相信你会站在很高的舞台并且保持努力的</p>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch 环境配置</title>
      <link href="//Pytorch-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>//Pytorch-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p> 前言：配环境还真是技术员们的一大难题，每次配环境看着视频以为很简单，结果自己出现各种各样的错误，我本来是看了小土堆的视频来配置Pytorch视频的,但其实对现在已经不太适用了（仅仅代表个人看法）</p><h1 id="Pytorch环境配置"><a href="#Pytorch环境配置" class="headerlink" title="Pytorch环境配置"></a>Pytorch环境配置</h1><p>1.下载anaconda3</p><p><a href="http://www.anaconda.com/">www.anaconda.com</a></p><p>这个正常在网站上安装就好了，但是要注意盘别乱安装。我就是第一次安装在D，然后后面环境又在C导致错误了。不妨就<strong>按照系统的放在C盘，之后也很OK</strong>。</p><p>如果想使用anaconda的历史版本 （<a href="https://repo.anaconda.com/">https://repo.anaconda.com/</a>)</p><p>下载过程可能中间会卡住一段很正常，耐心等待就好了。</p><hr><blockquote><p>2.安装完成后在菜单的<strong>Anaconda Prompt</strong> 中运行指令：<br><code>conda create -n pytorch python=3.9</code></p></blockquote><p>这个地方为什么是3.9 我觉得有点讲究的 我刚开始就是按照视频的3.6，后面发现没用。</p><p>后面遇到y&#x2F;n 一直按y就好了</p><hr><p>3.安装好后可能每次进入都是base环境 这个时候就需要记住一个指令：</p><blockquote><p><code>conda activate pytorch</code></p></blockquote><p>这个时候左边的（base) 就变成了（pytorch)了</p><p>环境就变成pytorch环境</p><p>取消环境的话 </p><blockquote><p><code>conda deactivate</code></p></blockquote><hr><p>4.接着就是开始pytorch的安装</p><p><a href="https://pytorch.org/">https://pytorch.org/</a></p><p>这个是官网链接</p><p>进去后你就会发现有个</p><blockquote><p><strong>NOTE:</strong> Latest PyTorch requires Python 3.9 or later.</p></blockquote><p>所以这就是为什么上面我说python&#x3D;3.9的原因</p><p>小土堆视频是conda安装 但是现在好像不能conda安装了，以下是官方文件：</p><blockquote><p>PyTorch官方在2024年底发布公告，宣布不再维护Conda包，原因是<strong>Conda的维护成本过高</strong><a href="https://blog.csdn.net/gabi75888/article/details/145677978">1</a><a href="https://blog.csdn.net/LBJ170/article/details/146074211">2</a>。因此，PyTorch官网安装页面上出现了“Conda packages are no longer available. Please use pip instead.”的提示<a href="https://blog.csdn.net/gabi75888/article/details/145677978">1</a>。</p></blockquote><p>所以下面我来介绍pip的安装方式：</p><p>你可以通过Win+R输入cmd,进入后输入：</p><blockquote><p><code>nvidia-smi</code></p></blockquote><p>我的是 <strong>CUDA Version: 12.6</strong></p><p><img src="C:\Users\QuCheng\AppData\Roaming\Typora\typora-user-images\image-20250330163729658.png" alt="image-20250330163729658"></p><p>复制command即可，如果你想安装其他版本的可以在<a href="https://pytorch.org/get-started/previous-versions/">Previous PyTorch Versions | PyTorch</a></p><p><strong>我下载的时候是有点慢的 可以稍微等一等</strong></p><p>或者小土堆视频下方有下载链接 你可以按照他的视频去操作 但感觉不一定适用 因为他之前是package是conda.</p><hr><p>5.在Pytorch下的时候是：</p><p><code>（pytorch)C:\Users\用户名&gt;</code></p><p>输入</p><blockquote><p><code>（pytorch)C:\Users\用户名&gt;python</code></p></blockquote><p><img src="C:\Users\QuCheng\AppData\Roaming\Typora\typora-user-images\image-20250330164230165.png" alt="image-20250330164230165"></p><p>进入python环境后，再输入</p><blockquote><p><code>import torch</code></p></blockquote><p>没报错的话稍微等一会会出现&gt;&gt;&gt;</p><p>下面来看下pytorch是否能使用GPU</p><blockquote><p><code>torch.cuda.is_available()</code></p></blockquote><p>返回True</p><p>这样就表示你的电脑的GPU是可以被pytorch使用的。</p><p><img src="C:\Users\QuCheng\AppData\Roaming\Typora\typora-user-images\image-20250404210031767.png" alt="image-20250404210031767"></p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>To future</title>
      <link href="//To-future/"/>
      <url>//To-future/</url>
      
        <content type="html"><![CDATA[<h1 id="To-Future"><a href="#To-Future" class="headerlink" title="To Future"></a>To Future</h1><p>现在已经是三月二十一日凌晨一点了，和赫哥聊天从十点钟聊到十二点多。不可否认的赫哥是我学习路上的引路人吧，我觉得可以算是我师父了，只是他比较谦虚，以学长的方式敬称。看的出来赫哥是一个很有野心的人，技术和学术界两脚都站。我其实对于学术和技术这两方面其实都是模糊状态，和他聊完后，有以下几点感受：</p><hr><p>1.坚定学术方向</p><p>他举例子很简单，你好好干学术，之后薪资待遇。他说带你到深圳广东那边逛一遍，你会发现技术根本赚不了多少。其实最终管人的人才是不变的，这一点你要先意识的到，才能更好的想好未来该干的事情。技术是在不断创新的，但是你管理层的人很难发生改变的。没说你一定要读书读到博士，但至少要硕士毕业吧，把你自己的上限提高，以一个南京大学在绿盟工作的案例给我举例了。好好干学术，跟着老师学，跟着师兄干。</p><hr><p>2。对钱的理解</p><p>赫哥说了如果真的需要用钱，可以去他那边干，给你开几千块的薪资。其实今天干了一天你发现，自己也没学到啥，干这个什么线上录播课，纯tmd浪费时间，那么多规则，还不如挣个家教来的实在。</p><p>谈到家教这个事情，赫哥也有比较不错的看法。你现在先跟着老师好好干，好好学，混个半年到时候熟悉了，（你可以直接和老师讲家里的经济条件一般或者自己想赚钱养家啥的），先跟老师打好关系，再做下一步打算，懂吧！纵向（学术）干的差不多了就可以和老师说我要干横向，到时候老师安排你去经常外包的公司远程打工，不会很累的，老师还摆在这，他们看的懂的。学术上好好研究，这点小钱，真没必要花大量的时间成本去赚。还不如到时候等赫哥论文搞完，去跟着他学一点技术，挖挖漏洞啥的。</p><hr><p>好了，总结来说：就是好好搞绩点，卷到个rank1去，技术界那一块就没必要管，也没必要去卷。卷好学术这一块需要的技术就ok的！！其实有些是交叉的没问题，了解知识总是好事嘛！！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transformer</title>
      <link href="//Transformer/"/>
      <url>//Transformer/</url>
      
        <content type="html"><![CDATA[<p>1.特点<br>使用&#x3D;&#x3D;注意力&#x3D;&#x3D;来提高这些模型训练速度的模型<br>（最大的好处源于The Transformer如何使自己适合并行化）<br>2.介绍<br>Transformer抛弃了传统的CNN和RNN,整个网络结构完全是由<strong>Attention机制</strong>组成。</p><p>RNN计算限制：<br>1.简介<br>RNN算法只能从左向右依次计算<br>2.问题<br>–时间t依赖t-1时刻的计算结果，这样<strong>限制了模型的并行能力；</strong><br>–顺序计算的过程信息会丢失，尽管LSTM(长短时记忆网络)（这是一种改进后的循环神经网络，能够解决RNN无法处理长距离依赖的问题 通过引入三个门（遗忘门、输出门和输出门）来控制信息的流动，从而更好地处理序列中的长期依赖关系 )一定程度上缓解了长期依赖的问题，但是对于长期依赖现象，LSTM依旧无能为力。</p><p>Transformer的好处（也就是解决方法）<br>–使用了attention机制，将序列中任意两个位置的距离缩小为一个常量<br>–不是RNN的顺序结构，因此具有很好的并行性</p><p><em>&#x3D;&#x3D;<em>Transformer结构</em></em>&#x3D;&#x3D;：<br>1.输入–小黑盒–输出</p><p>2.小黑盒：<br><strong>Encoders</strong> + <strong>Decoders</strong><br>Encoder编码组件是一堆编码器（论文上将六个堆在一起–数字6并没有什么神奇之处）。解码组件是一堆相同数量的解码器。</p><p>3.Encoder编码器：<br>self-attention  —-Feed Forward Neural Network(前馈神经网络)<br>过程：<br>self-attention:这层帮助编码器在对特定单词进行<strong>编码</strong>时<strong>查看输入句子中的其他句子</strong>。<br>自注意力层的输出被馈送到Feed Forward Neural Network.(完全相同的前馈网络独立应用于每个位置)</p><p>4.Decoder解码器<br>解码器具有三个层，比encoder编码器多一个Encoder-Decoder Attention，<br>作用是<strong>帮助机器专注于句子输入句子的相关部分</strong></p><p>输入编码的详细过程：<br>1.Embedding嵌入算法将每个输入单词转换为向量<br>（每个单词都嵌入到大小为512的向量中）<br>Embedding嵌入仅发生在最底部的编码器中。<br>所有编码器共有的抽象是它们接受一个大小为512的向量列表–在编码器中，这将是嵌入。<br>（但是在其他编码器中就是输入–直接在下方的编码器中输出）<br>这个列表的大小是我们可以设置的<strong>超参数-</strong>–%% 基本上它是我们训练数据集中最长句子的长度。 %%</p><p>&#x2F;&#x2F;在自注意力层Self-Attention中，这些路径之间存在<strong>依赖</strong>关系。然而，Feed <strong>Forward前馈层没有这些依赖关系</strong>。—因此各种路径可以在流过前馈层的同时并行执行</p><p>Transformer模型<br><a href="https://colab.research.google.com/github/tensorflow/tensor2tensor/blob/master/tensor2tensor/notebooks/hello_t2t.ipynb#scrollTo=s19ucTii_wYb">Tensor2Tensor 简介 - Colab — Tensor2Tensor Intro - Colab</a></p><p>self-attention具体步骤：<br><strong>question:如何使用向量计算自注意力</strong><br>-1.从每个编码器的输入向量创建三个向量Q，K，V</p><ul><li>(Q是查询向量，K是键向量，V是一个值向量)</li><li>–1.从每个编码器的输入向量创建三个向量Q，K，V（在这种情况下，每个词的嵌入）</li><li>–2.这些向量是通过嵌入乘以我们在训练过程中训练的三个矩阵来创建的</li><li>–3.新向量Q，K，V的维度小于嵌入向量，维度为64,它们不必更小，这是使多头注意力（大部分）的计算保持不变的架构选择。</li><li>（嵌入和编码器输入&#x2F;输出向量维数为512）</li></ul><p>现在可能有一个问题就是你并没有理解查询Q，键K，值V向量<br>&#x3D;&#x3D;其实它们就是计算和思考注意力的抽象概念&#x3D;&#x3D;</p><p>-2.<br>第二步是计算一个分数<br>-3.4.将分数除以8，然后通过softmax操作传递结果<br>（Softmax将分数归一化，因此它们都是正数并且加起来为1）<br>%% Softmax分数：决定了每个单词在这个位置上的表达量。显然，这个位置的单词具有最高的softmax分数，但有时关注与当前单词相关的另一个单词很有用 %%<br>-5.将每个值向量乘以softmax分数<br>（这里的直觉是保持我们想要关注的单词的值不变，并淹没不相关的单词<br>-6.对加权值向量求和。<br>（这会在这个位置产生自注意力层的输出）</p><p><strong>question:自注意力的矩阵计算</strong><br>-1.计算查询Q，键K和值V矩阵<br>（通过将嵌入打包到矩阵X中，并将乘以我们训练的权重矩阵来做到这一点）</p><p>&#x3D;&#x3D;多头注意力机制&#x3D;&#x3D;<br>好处：进一步完善了自注意力层self-attention</p><blockquote><p>[!NOTE]</p></blockquote><blockquote><p>它扩展了<strong>模型关注不同位置的能力</strong>。是的，在上面的示例中，z1 包含一点其他编码，但它可能由实际单词本身主导。如果我们要翻译“The animal didn’t cross the street because it was too tired”这样的句子，那么知道“it”指的是哪个词会很有用。</p><p>它为注意力层<strong>提供了多个“表示子空间</strong>”。正如我们接下来将看到的，使用多头注意力，我们不仅有一个，而且还有多组查询&#x2F;键&#x2F;值权重矩阵（Transformer 使用八个注意力头，所以我们最终每个编码器&#x2F;解码器都有八个集合） . 这些集合中的每一个都是随机初始化的。然后，在训练之后，每个集合用于将输入嵌入（或来自较低编码器&#x2F;解码器的向量）投影到不同的表示子空间中。</p></blockquote><p>解码器堆栈输出一个浮点向量。<br>question:如何变成一个词<br>（这是最后一个线性层的工作，后面一个是softmax层）</p><p>线性层：<br>是一个简单的全连接神经网络，它将解码器堆栈产生的向量投影到一个更大的向量（logits向量）中</p><p>**残差（**The Residuals Network)<br>编码器架构中的一个细节是每个编码器中的每个子层在其周围都有一个残差连接，然后是一个层归一化的步骤</p><p><strong>解码器端</strong>（The Decoder Side)<br>解码器首先处理输入序列。然后将顶部编码器的输出转换成一组注意向量K和V。这些将由每个解码器在其“编码器-解码器”层使用，这有助于解码器将注意力集中在输入序列的适当位置。</p><p>以下步骤重复该过程，直到出现特殊到达符号表示变压器解码器已完成其输出。每一步的输出在下一步被亏送到底部的解码器，解码器就像编码器一样冒泡它们的解码结果。就像我们对编码器输入所做的那样，我们将位置编码嵌入并添加到这些解码器输入中，以指示每个单词的位置。</p><p>解码器中的自注意力层的操作方式与编码器中的方式略有不同：</p><p>在解码器中，自注意力层只允许关注&#x3D;&#x3D;输出序列中较早的位置&#x3D;&#x3D;。这是通过在 self-attention 计算中的 softmax 步骤之前masking屏蔽未来位置（将它们设置为 ）来完成的。</p><p>“Encoder-Decoder Attention”层的工作方式与多头自注意力相似，不同之处在于它从&#x3D;&#x3D;其下方的层创建其查询矩阵&#x3D;&#x3D;，并从编码器堆栈的输出中获取 Keys 和 Values 矩阵。</p><p>中间省略了使用位置编码表示序列的顺序</p><p>本文章参照<br><a href="https://blog.csdn.net/zgpeace/article/details/126635650">翻译: 详细图解Transformer多头自注意力机制 Attention Is All You Need-CSDN博客</a><br>我希望您发现这是一个有用的地方，可以开始使用 Transformer 的主要概念打破僵局。如果您想更深入，我建议您执行以下步骤：<br>观看原作的视频：<a href="https://youtu.be/-QH8fRhqFHM">https://youtu.be/-QH8fRhqFHM</a></p><p>阅读Attention Is All You Need论文、Transformer 博客文章（Transformer: A Novel Neural Network Architecture for Language Understanding）和Tensor2Tensor 公告。<br>观看Łukasz Kaiser 的演讲，了解模型及其细节<br>使用作为 Tensor2Tensor 存储库的一部分提供的Jupyter Notebook<br>探索Tensor2Tensor repo。<br>参考<br><a href="https://arxiv.org/abs/1706.03762">https://arxiv.org/abs/1706.03762</a><br><a href="https://jalammar.github.io/illustrated-transformer/">https://jalammar.github.io/illustrated-transformer/</a><br><a href="https://zhuanlan.zhihu.com/p/48508221">https://zhuanlan.zhihu.com/p/48508221</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迷茫中</title>
      <link href="//%E8%BF%B7%E8%8C%AB%E4%B8%AD/"/>
      <url>//%E8%BF%B7%E8%8C%AB%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<p>不知道咋说 最近确实很迷茫</p>]]></content>
      
      
      
        <tags>
            
            <tag> future </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.21blog</title>
      <link href="//2-21blog/"/>
      <url>//2-21blog/</url>
      
        <content type="html"><![CDATA[<p>最近有点tired 而且还有点小摆烂<br>但我明白我会对自己负责 对自己的简历负责 对我的未来负责<br>以后的我会把我现在少玩的全部玩回来<br>你一定要清楚什么时间什么阶段做什么事情，你以后要变成什么样的人，你现在就要付出什么样的行动，你现在该怎么样努力，不要活的稀里糊涂，你要清楚，开心与痛苦是并存的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLM模型</title>
      <link href="//LLM%E6%A8%A1%E5%9E%8B/"/>
      <url>//LLM%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="LLM大模型"><a href="#LLM大模型" class="headerlink" title="LLM大模型"></a>LLM大模型</h1><p>1.好用的ai:</p><p><img src="https://qucheng-wuan.oss-cn-wuhan-lr.aliyuncs.com/img/image-20250219164436504.png" alt="image-20250219164436504"></p><p>2.不同语言模型的Token是不一样的</p><p>3.每次答案都不一一样 是因为ai回答具有随机性</p><p>你输入文字后他会**“文字接龙”**，选择提示词后面可能出现概率最高的字进行接龙</p><p><img src="https://qucheng-wuan.oss-cn-wuhan-lr.aliyuncs.com/img/image-20250219165229710.png" alt="image-20250219165229710"></p><p>为什么这个回答有点像掷骰子？因为如果每次都选概率最大的，那么ai会不断重复自己的话语，而随机性就可以让ai较自然的回答</p><p>4.语言模型怎么学习文字接龙？</p><p>任何文句都可以是教材！</p><p>Eg.“人工智慧真神奇”  语言模型接收到这句话后，通俗来说，就是增强了“人”后面接龙”工”的概率。</p><p>5.语言模型的背后实质就是类神经网络，里面有上亿个参数</p><p>具体神经网络和参数如何被造出来的—见”李宏毅的机器学习2021“</p><p>6.以前的gpt学习就是通过爬网络上的资料–预训练（自督导式学习）        后面的chatgpt学习会通过人类的话来进行学习（督导式学习）</p><p>GPT—(通过微调)—ChatGPT</p><p>7.<strong>有预训练后，督导式学习不用大量的资料</strong></p><p>在多种语言上做预训练后，只要教某一个语言的某一个任务，自动学会其他语言的同样任务。</p><p>8.预训练—督导式训练—增强式训练（模型要有一定能力才能接入RLHF）</p><p>9.面对ai的语言</p><p>—1.把需求说清楚</p><p>—-2.提供资讯给ChatGPT(以防gpt胡乱发挥)</p><p>—-3.提供范例（以防他不熟悉潮流词汇）</p><p><img src="https://qucheng-wuan.oss-cn-wuhan-lr.aliyuncs.com/img/image-20250220194505505.png" alt="image-20250220194505505"></p><p>—–4.鼓励ChatGPT想一想（不要他直接给答案 让他列出过程）</p><p>—–5.找神奇咒语</p><p><img src="https://qucheng-wuan.oss-cn-wuhan-lr.aliyuncs.com/img/image-20250220194829469.png" alt="image-20250220194829469"></p><p>—–6. 不断输入详细的需要</p><p>eg.先叫他给你文本内容—制作每张幻灯片的内容—可以下载幻灯片</p><p>—–7.ChatGPT可以使用其他工具（用其他ai工具嵌入chatgpt)</p><p>不要认为chat+搜索引擎就无敌 了解他的原理你就知道他是可能就某一个标题缩写后得成的</p><p>——8.拆解任务 （拆解+大纲—让他加强）</p><p><img src="https://qucheng-wuan.oss-cn-wuhan-lr.aliyuncs.com/img/image-20250220195419206.png" alt="image-20250220195419206"></p><p>—–9.自主进行规划</p><p>大任务—chat—多个小任务—每个小任务对应gpt</p><p>—–10.chat是会自我反省的 但需要4以上的模型</p><p>两个思路：</p><p>—改变自己来强化模型</p><p>—训练自己的模型</p><p>—–11.语言模型是怎么使用工具的呢？</p><p><img src="https://qucheng-wuan.oss-cn-wuhan-lr.aliyuncs.com/img/image-20250222204539879.png" alt="image-20250222204539879"></p><p>—–12.模型合作：让模型彼此讨论</p><p><img src="https://qucheng-wuan.oss-cn-wuhan-lr.aliyuncs.com/img/image-20250222212039714.png" alt="image-20250222212039714"></p><p>—–13.overfitting</p><p>是指训练成功但测试失败</p><p>机器学习时只管找到的参数有没有符合训练资料，不管有没有道理—–需要增加训练资料的多样 性</p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Future</title>
      <link href="//Future/"/>
      <url>//Future/</url>
      
        <content type="html"><![CDATA[<h1 id="谈未来"><a href="#谈未来" class="headerlink" title="谈未来"></a>谈未来</h1><p>今天没怎么卷 但是还是比较充实的 上午看了看单词 刷刷acwing的课程 下午正常上课 （虽然上课在睡觉 但是真的很无聊 懒得喷）</p><p>下午上课结束来到实验室，今天和future聊天收获颇丰，确实走在时代前沿才是最不可能被时代淘汰的人，刚开始os群里一堆人在玩ai，你是真的懒，dp这东西没好好玩，其实这个服务器算是future帮我搭建好了的 ，然后我只是相当于加入他的团体使用dp。现在手机和电脑都可以使用了，再也不怕”服务器繁忙了“。</p><p>晚上聊了下保研和gap的事情 </p><h2 id="收获："><a href="#收获：" class="headerlink" title="收获："></a>收获：</h2><p>1.gap这个东西是需要你有推荐信的，不是你想去就去的，这个道理要懂。</p><p>2.gap需要雅思、托福也就是学校认可你，这个你得懂哈！</p><p>3.保研和你这个体育加分好像没什么关系</p><p>4.发论文很重要，早点找导师，然后开始学习，当然慢慢来，文章也不是这么好发的，了解吧！</p><p>5.找实习不是去厂里实习 而是去那些什么lab实习到时候有可能被招进去就挺好的</p><p>6.gap不一定非要研究生阶段去，博士生被外派留学也挺好啊，说不定还公费呢！其实外面的研究氛围和资料交流啥的也蛮好的</p><p>7.加油吧 事情往积极的地方想 不用想太多 脚踏实地 开心每一天啦</p>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS启蒙课</title>
      <link href="//CS%E5%90%AF%E8%92%99%E8%AF%BE/"/>
      <url>//CS%E5%90%AF%E8%92%99%E8%AF%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="科普视频：Crash-Course-Computer-Science"><a href="#科普视频：Crash-Course-Computer-Science" class="headerlink" title="科普视频：Crash Course:Computer Science"></a>科普视频：Crash Course:Computer Science</h1><ol start="3"><li></li></ol><p>Not:相反</p><p>And:true,true–true</p><p>​        true,false–false</p><p>​        false,false–false</p><p>OR:类似于并联</p><p><img src="https://qucheng-wuan.oss-cn-wuhan-lr.aliyuncs.com/img/image-20250216104439390.png" alt="image-20250216104439390"></p><p>NOR:相同则异，异则相同</p><p><img src="https://qucheng-wuan.oss-cn-wuhan-lr.aliyuncs.com/img/image-20250216104556923.png" alt="image-20250216104556923"></p><p>4.二进制比较简单了 这个就不多赘述了</p><ol start="5"><li></li></ol><p>ALU：计算机里负责运算的组件，基本其他所有部件都用到了他</p><p>两个单元：一个算术单元，一个逻辑单元</p>]]></content>
      
      
      
        <tags>
            
            <tag> CS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DevC++如何有效调用GTK库</title>
      <link href="//DevC-%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E8%B0%83%E7%94%A8GTK%E5%BA%93/"/>
      <url>//DevC-%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E8%B0%83%E7%94%A8GTK%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>1.搜索GTK，官网教程会教你如何使用mysy2来下载GTK库  然后进行各种包的更新 </p><p>2.<img src="https://qucheng-wuan.oss-cn-wuhan-lr.aliyuncs.com/img/image-20250211183931982.png" alt="image-20250211183931982"></p><p>这是用户变量里面要添加的内容</p><ol start="3"><li><img src="https://qucheng-wuan.oss-cn-wuhan-lr.aliyuncs.com/img/image-20250211192314954.png" alt="image-20250211192314954"></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++语法学习</title>
      <link href="//C-%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>//C-%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="C-语法学习"><a href="#C-语法学习" class="headerlink" title="C++语法学习"></a>C++语法学习</h1><h2 id="C-基本语法"><a href="#C-基本语法" class="headerlink" title="C++基本语法"></a>C++基本语法</h2><h3 id="C-语句块"><a href="#C-语句块" class="headerlink" title="C++语句块"></a>C++语句块</h3><p>C++不以行末作为结束符的标识，因此，可以在一行上放置多个语句</p><blockquote><p><code>x = y;</code><br><code>y = y+1;</code><br><code>add(x, y);</code></p></blockquote><p>等同于</p><blockquote><p><code>x = y; y = y+1; add(x, y);</code></p></blockquote><h3 id="C-标识符"><a href="#C-标识符" class="headerlink" title="C++标识符"></a>C++标识符</h3><p>C++标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以<strong>字母A-Z或a-z或下划线_开始</strong>，后跟<strong>零个或多个字母、下划线和数字__（0-9）</strong>.</p><p>C++标识符不允许出现标点字符，比如@、&amp;和%。</p><p>C++是区分大小写的编程语言。   Eg.Manpower和manpower是两个不同的标识符。</p><p>下面列出几个有效的标识符：</p><blockquote><p>mohd       zara    abc   move_name  a_123<br>myname50   _temp   j     a23b9      retVal</p></blockquote><h3 id="C-数据类型"><a href="#C-数据类型" class="headerlink" title="C++数据类型"></a>C++数据类型</h3><p>1.变量存储信息时 <u>变量保留的是他所存储值的内存的位置</u></p><p>2.基本的内置类型</p><table><thead><tr><th align="left">类型</th><th align="left">关键字</th></tr></thead><tbody><tr><td align="left">布尔型</td><td align="left">bool</td></tr><tr><td align="left">字符型</td><td align="left">char</td></tr><tr><td align="left">整型</td><td align="left">int</td></tr><tr><td align="left">浮点型</td><td align="left">float</td></tr><tr><td align="left">双浮点型</td><td align="left">double</td></tr><tr><td align="left">无类型</td><td align="left">void</td></tr><tr><td align="left">宽字符型</td><td align="left">wchar_t</td></tr></tbody></table><p>注：其实wchar_t是这样来的：</p><blockquote><p>typedef  short  int  wchar_t;</p></blockquote><p>所以wchar_t实际的空间和short int一样</p><p>3.修饰符</p><table><thead><tr><th align="left">修饰符</th><th align="left">描述</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><code>signed</code></td><td align="left">表示有符号类型（默认）</td><td align="left"><code>signed int x = -10;</code></td></tr><tr><td align="left"><code>unsigned</code></td><td align="left">表示无符号类型</td><td align="left"><code>unsigned int y = 10;</code></td></tr><tr><td align="left"><code>short</code></td><td align="left">表示短整型</td><td align="left"><code>short int z = 100;</code></td></tr><tr><td align="left"><code>long</code></td><td align="left">表示长整型</td><td align="left"><code>long int a = 100000;</code></td></tr><tr><td align="left"><code>const</code></td><td align="left">表示常量，值不可修改</td><td align="left"><code>const int b = 5;</code></td></tr><tr><td align="left"><code>volatile</code></td><td align="left">表示变量可能被意外修改，禁止编译器优化</td><td align="left"><code>volatile int c = 10;</code></td></tr><tr><td align="left"><code>mutable</code></td><td align="left">表示类成员可以在 <code>const</code> 对象中修改</td><td align="left"><code>mutable int counter;</code></td></tr></tbody></table><p>所以说const也不是一定不能修改的  用mutable即可</p><p><strong>注意</strong>：不同系统会有差异，一字节为8位。</p><p><strong>注意</strong>：默认情况下，int、short、long都是带符号的，即signed</p><p><strong>注意</strong>：long int 8个字节，int 都是4个字节，（早期的C编译器定义了long int占用4个字节，int占用2个字节，新版的C&#x2F;C++标准兼容了早期的这一设定）</p><p><strong>注意</strong>：endl 这个是将在每一行后面添加一个换行符</p><p>例子：</p><blockquote><p><code>#include&lt;iostream&gt;   #include &lt;limits&gt;</code></p><p><code>using namespace std;</code>  </p><p><code>int main()   &#123;   cout &lt;&lt; &quot;type: \t\t&quot; &lt;&lt; &quot;************size**************&quot;&lt;&lt; endl;   cout &lt;&lt; &quot;bool: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(bool);   cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;bool&gt;::max)();   cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;bool&gt;::min)() &lt;&lt; endl</code></p></blockquote><p><img src="https://qucheng-wuan.oss-cn-wuhan-lr.aliyuncs.com/img/image-20250202133229340.png" alt="image-20250202133229340"></p><p>4.派生数据类型</p><table><thead><tr><th align="left">数据类型</th><th align="left">描述</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><code>数组</code></td><td align="left">相同类型元素的集合</td><td align="left"><code>int arr[5] = &#123;1, 2, 3, 4, 5&#125;;</code></td></tr><tr><td align="left"><code>指针</code></td><td align="left">存储变量内存地址的类型</td><td align="left"><code>int* ptr = &amp;x;</code></td></tr><tr><td align="left"><code>引用</code></td><td align="left">变量的别名</td><td align="left"><code>int&amp; ref = x;</code></td></tr><tr><td align="left"><code>函数</code></td><td align="left">函数类型，表示函数的签名</td><td align="left"><code>int func(int a, int b);</code></td></tr><tr><td align="left"><code>结构体</code></td><td align="left">用户定义的数据类型，可以包含多个不同类型的成员</td><td align="left"><code>struct Point &#123; int x; int y; &#125;;</code></td></tr><tr><td align="left"><code>类</code></td><td align="left">用户定义的数据类型，支持封装、继承和多态</td><td align="left"><code>class MyClass &#123; ... &#125;;</code></td></tr><tr><td align="left"><code>联合体</code></td><td align="left">多个成员共享同一块内存</td><td align="left"><code>union Data &#123; int i; float f; &#125;;</code></td></tr><tr><td align="left"><code>枚举</code></td><td align="left">用户定义的整数常量集合</td><td align="left"><code>enum Color &#123; RED, GREEN, BLUE &#125;;</code></td></tr></tbody></table><p>5.typedef声明</p><p>可以用typedef为一个已有的变量取一个新名字</p><p>定义的语法：<code>typedef type newname;</code> </p><p>例子：<code>typedef int feet;</code>（这个语句会告诉编译器 feet是int的另一个名称</p><p>因此:<code>feet distance</code> 创建的整型变量distance是合法的</p><p>6.枚举类型</p><p>”枚举“是指将变量中的值一一列举出来</p><blockquote><p>形式：enum 枚举名{<br>标识符[&#x3D;整型常数],<br>标识符[&#x3D;整型常数],<br>…<br>标识符[&#x3D;整型常数]<br>} 枚举变量</p></blockquote><p>如果枚举没有初始化, 即省掉”&#x3D;整型常数”时, 则从第一个标识符开始。</p><p>例子：</p><blockquote><p><code>enum color &#123; red, green, blue &#125; c;</code><br><code>c = blue;</code></p></blockquote><p>默认情况下，第一个值为0，第二个为1，以此类推</p><p>也可以给名称赋予一个特殊的值，只需要添加一个初始值即可</p><blockquote><p>enum color { red, green&#x3D;5, blue };</p></blockquote><p>这个例子red依然是0 ，green是5，blue是6</p><h3 id="C-变量作用域"><a href="#C-变量作用域" class="headerlink" title="C++变量作用域"></a>C++变量作用域</h3><p>1.初始局部变量和全局变量</p><p>当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动初始化为下列值：</p><table><thead><tr><th align="left">数据类型</th><th align="left">初始化默认值</th></tr></thead><tbody><tr><td align="left">int</td><td align="left">0</td></tr><tr><td align="left">char</td><td align="left">‘\0’</td></tr><tr><td align="left">float</td><td align="left">0</td></tr><tr><td align="left">double</td><td align="left">0</td></tr><tr><td align="left">pointer</td><td align="left">NULL</td></tr></tbody></table><p>正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果。</p><p>块作用域：</p><p>  定义：在代码块内部声明的变量</p><p>（其实也就是大括号里面带大括号）</p><blockquote><p><code>#include &lt;iostream&gt;</code></p><p><code>int main() &#123;</code><br> <code>int a = 10;</code><br> <code>&#123;</code><br>     <code>int a = 20;  // 块作用域变量</code><br>     <code>std::cout &lt;&lt; &quot;块变量: &quot; &lt;&lt; a &lt;&lt; std::endl;</code><br> <code>&#125;</code><br> <code>std::cout &lt;&lt; &quot;外部变量: &quot; &lt;&lt; a &lt;&lt; std::endl;</code><br> <code>return 0;</code><br><code>&#125;</code></p><p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20250205141259313.png" alt="image-20250205141259313"></p></blockquote><p><img src="https://qucheng-wuan.oss-cn-wuhan-lr.aliyuncs.com/img/image-20250205141131079.png" alt="image-20250205141131079"></p><h3 id="C-常量"><a href="#C-常量" class="headerlink" title="C++常量"></a>C++常量</h3><h4 id="1-整数常量"><a href="#1-整数常量" class="headerlink" title="1.整数常量"></a>1.整数常量</h4><p>前缀：</p><p>  十六进制：0x      八进制：0     十进制：不带前缀默认</p><p>后缀：</p><p> U 和L的组合</p><p>U：无符号整数</p><p>L：长整数</p><p>后缀可以大写 两者顺序随意</p><h4 id="2-浮点常量"><a href="#2-浮点常量" class="headerlink" title="2.浮点常量"></a>2.浮点常量</h4><p>组成：整数部分、小数部分、小数点、指数部分</p><p>例子：</p><blockquote><p>3.14159       &#x2F;&#x2F; 合法的<br>314159E-5L    &#x2F;&#x2F; 合法的               这个代表10的-5次方 L是长双精度浮点数<br>510E          &#x2F;&#x2F; 非法的：不完整的指数<br>210f          &#x2F;&#x2F; 非法的：没有小数或指数<br>.e55          &#x2F;&#x2F; 非法的：缺少整数或分数</p></blockquote><h4 id="3-布尔常量（bool"><a href="#3-布尔常量（bool" class="headerlink" title="3.布尔常量（bool)"></a>3.布尔常量（bool)</h4><p>一个<strong>true</strong> 一个<strong>false</strong></p><p>注意：不能把true看成1 false看成0 这两个都是C++的关键字</p><h4 id="4-字符常量"><a href="#4-字符常量" class="headerlink" title="4.字符常量"></a>4.字符常量</h4><p>字符常量是括在<strong>单引号</strong>里面的（‘ ’）</p><p>转义字符码：</p><table><thead><tr><th align="left">转义序列</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">\</td><td align="left">\ 字符</td></tr><tr><td align="left">&#39;</td><td align="left">‘ 字符</td></tr><tr><td align="left">&quot;</td><td align="left">“ 字符</td></tr><tr><td align="left">?</td><td align="left">? 字符</td></tr><tr><td align="left">\a</td><td align="left">警报铃声</td></tr><tr><td align="left">\b</td><td align="left">退格键</td></tr><tr><td align="left">\f</td><td align="left">换页符</td></tr><tr><td align="left"><strong>\n</strong></td><td align="left"><strong>换行符</strong></td></tr><tr><td align="left">\r</td><td align="left">回车</td></tr><tr><td align="left"><strong><strong>\t</strong></strong></td><td align="left"><strong>水平制表符</strong></td></tr><tr><td align="left">\v</td><td align="left">垂直制表符</td></tr><tr><td align="left">\ooo</td><td align="left">一到三位的八进制数</td></tr><tr><td align="left">\xhh . . .</td><td align="left">一个或多个数字的十六进制数</td></tr></tbody></table><h4 id="5-字符串常量"><a href="#5-字符串常量" class="headerlink" title="5.字符串常量"></a>5.字符串常量</h4><p>括在**“ ”**里面</p><p>一个字符串包含类似一字符常量的字符：普通的字符、转移序列和通用的字符。</p><p>也可以用****做分隔符，把一个很长的字符串常量进行分行；</p><h4 id="6-定义常量"><a href="#6-定义常量" class="headerlink" title="6.定义常量"></a>6.定义常量</h4><p>两种方式：</p><blockquote><ul><li>使用 <strong>#define</strong> 预处理器。</li><li>使用 <strong>const</strong> 关键字。</li></ul></blockquote><h3 id="C-运算符"><a href="#C-运算符" class="headerlink" title="C++运算符"></a>C++运算符</h3><h4 id="1-算术运算"><a href="#1-算术运算" class="headerlink" title="1.算术运算"></a>1.算术运算</h4><p>+-&#x2F; % ++  –</p><h4 id="2-关系运算符"><a href="#2-关系运算符" class="headerlink" title="2.关系运算符"></a>2.关系运算符</h4><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&#x3D;&#x3D;</td><td align="left">检查两个操作数的值是否相等，如果相等则条件为真。</td><td align="left">(A &#x3D;&#x3D; B) 不为真。</td></tr><tr><td align="left">!&#x3D;</td><td align="left">检查两个操作数的值是否相等，如果不相等则条件为真。</td><td align="left">(A !&#x3D; B) 为真。</td></tr><tr><td align="left">&gt;</td><td align="left">检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td><td align="left">(A &gt; B) 不为真。</td></tr><tr><td align="left">&lt;</td><td align="left">检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td><td align="left">(A &lt; B) 为真。</td></tr><tr><td align="left">&gt;&#x3D;</td><td align="left">检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td><td align="left">(A &gt;&#x3D; B) 不为真。</td></tr><tr><td align="left">&lt;&#x3D;</td><td align="left">检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td><td align="left">(A &lt;&#x3D; B) 为真。</td></tr></tbody></table><h4 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3.逻辑运算符"></a>3.逻辑运算符</h4><p>下表显示了 C++ 支持的关系逻辑运算符。</p><p>假设变量 A 的值为 1，变量 B 的值为 0，则：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;&amp;</td><td align="left">称为逻辑与运算符。如果两个操作数都 true，则条件为 true。</td><td align="left">(A &amp;&amp; B) 为 false。</td></tr><tr><td align="left">||</td><td align="left">称为逻辑或运算符。如果两个操作数中有任意一个 true，则条件为 true。</td><td align="left">(A || B) 为 true。</td></tr><tr><td align="left">!</td><td align="left">称为逻辑非运算符。用来逆转操作数的逻辑状态，如果条件为 true 则逻辑非运算符将使其为 false。</td><td align="left">!(A &amp;&amp; B) 为 true。</td></tr></tbody></table><h4 id="4-位运算符（难一点）-理解"><a href="#4-位运算符（难一点）-理解" class="headerlink" title="4.位运算符（难一点） (理解)"></a>4.位运算符（难一点） (理解)</h4><p>下表显示了 C++ 支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;</td><td align="left">按位与操作，按二进制位进行”与”运算。运算规则：<code>0&amp;0=0;    0&amp;1=0;     1&amp;0=0;      1&amp;1=1;</code></td><td align="left">(A &amp; B) 将得到 12，即为 0000 1100</td></tr><tr><td align="left">|</td><td align="left">按位或运算符，按二进制位进行”或”运算。运算规则：&#96;0</td><td align="left">0&#x3D;0;    0</td></tr><tr><td align="left">^</td><td align="left">异或运算符，按二进制位进行”异或”运算。运算规则：<code>0^0=0;    0^1=1;    1^0=1;   1^1=0;</code></td><td align="left">(A ^ B) 将得到 49，即为 0011 0001</td></tr><tr><td align="left">~</td><td align="left">取反运算符，按二进制位进行”取反”运算。运算规则：<code>~1=-2;    ~0=-1;</code></td><td align="left">(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。</td><td align="left">A &lt;&lt; 2 将得到 240，即为 1111 0000</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</td><td align="left">A &gt;&gt; 2 将得到 15，即为 0000 1111</td></tr></tbody></table><h4 id="5-赋值运算符"><a href="#5-赋值运算符" class="headerlink" title="5.赋值运算符"></a>5.赋值运算符</h4><p>下表列出了 C++ 支持的赋值运算符：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&#x3D;</td><td align="left">简单的赋值运算符**，把右边操作数的值赋给左边操作数**</td><td align="left">C &#x3D; A + B 将把 A + B 的值赋给 C</td></tr><tr><td align="left">+&#x3D;</td><td align="left">加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td><td align="left">C +&#x3D; A 相当于 C &#x3D; C + A</td></tr><tr><td align="left">-&#x3D;</td><td align="left">减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td><td align="left">C -&#x3D; A 相当于 C &#x3D; C - A</td></tr><tr><td align="left">*&#x3D;</td><td align="left">乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td><td align="left">C *&#x3D; A 相当于 C &#x3D; C * A</td></tr><tr><td align="left">&#x2F;&#x3D;</td><td align="left">除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td><td align="left">C &#x2F;&#x3D; A 相当于 C &#x3D; C &#x2F; A</td></tr><tr><td align="left">%&#x3D;</td><td align="left">求模且赋值运算符，求两个操作数的模赋值给左边操作数</td><td align="left">C %&#x3D; A 相当于 C &#x3D; C % A</td></tr><tr><td align="left">&lt;&lt;&#x3D;</td><td align="left">左移且赋值运算符</td><td align="left">C &lt;&lt;&#x3D; 2 等同于 C &#x3D; C &lt;&lt; 2</td></tr><tr><td align="left">&gt;&gt;&#x3D;</td><td align="left">右移且赋值运算符</td><td align="left">C &gt;&gt;&#x3D; 2 等同于 C &#x3D; C &gt;&gt; 2</td></tr><tr><td align="left">&amp;&#x3D;</td><td align="left">按位与且赋值运算符</td><td align="left">C &amp;&#x3D; 2 等同于 C &#x3D; C &amp; 2</td></tr><tr><td align="left">^&#x3D;</td><td align="left">按位异或且赋值运算符</td><td align="left">C ^&#x3D; 2 等同于 C &#x3D; C ^ 2</td></tr><tr><td align="left">|&#x3D;</td><td align="left">按位或且赋值运算符</td><td align="left">C |&#x3D; 2 等同于 C &#x3D; C | 2</td></tr></tbody></table><h4 id="6-杂项运算符"><a href="#6-杂项运算符" class="headerlink" title="6.杂项运算符"></a>6.杂项运算符</h4><p>下表列出了 C++ 支持的其他一些重要的运算符。</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">sizeof</td><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-sizeof-operator.html">sizeof 运算符</a>返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。<strong>（字节）</strong></td></tr><tr><td align="left">Condition ? X : Y</td><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-conditional-operator.html">条件运算符</a>。如果 Condition 为真 ? 则值为 X : 否则值为 Y。</td></tr><tr><td align="left">,</td><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-comma-operator.html">逗号运算符</a>会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的<strong>最后一个表达式</strong>的值。</td></tr><tr><td align="left">.（点）和 -&gt;（箭头）</td><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-member-operators.html">成员运算符</a>用于引用类、结构和共用体的成员。</td></tr><tr><td align="left">Cast</td><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-casting-operators.html">强制转换运算符</a>把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。</td></tr><tr><td align="left">&amp;</td><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-pointer-operators.html">指针运算符 &amp;</a> 返回变量的地址。例如 &a; 将给出变量的<strong>实际地址</strong>。</td></tr><tr><td align="left">*</td><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-pointer-operators.html">指针运算符 *</a> 指向一个变量。例如，*var; 将<strong>指向</strong>变量 var。</td></tr></tbody></table><h4 id="运算符优先级（看看就是）"><a href="#运算符优先级（看看就是）" class="headerlink" title="运算符优先级（看看就是）"></a>运算符优先级（看看就是）</h4><p>下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。</p><table><thead><tr><th align="left">类别</th><th align="left">运算符</th><th align="left">结合性</th></tr></thead><tbody><tr><td align="left">后缀</td><td align="left">() [] -&gt; . ++ - -</td><td align="left">从左到右</td></tr><tr><td align="left">一元</td><td align="left">+ - ! ~ ++ - - (type)* &amp; sizeof</td><td align="left">从右到左</td></tr><tr><td align="left">乘除</td><td align="left">* &#x2F; %</td><td align="left">从左到右</td></tr><tr><td align="left">加减</td><td align="left">+ -</td><td align="left">从左到右</td></tr><tr><td align="left">移位</td><td align="left">&lt;&lt; &gt;&gt;</td><td align="left">从左到右</td></tr><tr><td align="left">关系</td><td align="left">&lt; &lt;&#x3D; &gt; &gt;&#x3D;</td><td align="left">从左到右</td></tr><tr><td align="left">相等</td><td align="left">&#x3D;&#x3D; !&#x3D;</td><td align="left">从左到右</td></tr><tr><td align="left">位与 AND</td><td align="left">&amp;</td><td align="left">从左到右</td></tr><tr><td align="left">位异或 XOR</td><td align="left">^</td><td align="left">从左到右</td></tr><tr><td align="left">位或 OR</td><td align="left">|</td><td align="left">从左到右</td></tr><tr><td align="left">逻辑与 AND</td><td align="left">&amp;&amp;</td><td align="left">从左到右</td></tr><tr><td align="left">逻辑或 OR</td><td align="left">||</td><td align="left">从左到右</td></tr><tr><td align="left">条件</td><td align="left">?:</td><td align="left">从右到左</td></tr><tr><td align="left">赋值</td><td align="left">&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D;&gt;&gt;&#x3D; &lt;&lt;&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D;</td><td align="left">从右到左</td></tr><tr><td align="left">逗号</td><td align="left">,</td><td align="left">从左到右</td></tr></tbody></table><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="C-for循环"><a href="#C-for循环" class="headerlink" title="C++for循环"></a>C++for循环</h3><p>1.正常版本</p><blockquote><p>for ( init; condition; increment )<br>{<br>statement(s);<br>}</p></blockquote><p>2.<img src="https://qucheng-wuan.oss-cn-wuhan-lr.aliyuncs.com/img/image-20250206164305706.png" alt="image-20250206164305706"></p><p>&amp;表示对x整数的引用 （每次循环迭代的时候，x都引用my_array中的元素，因此 对<code>x</code>的操作会直接反映在<code>my_array</code>上。</p><p><img src="https://qucheng-wuan.oss-cn-wuhan-lr.aliyuncs.com/img/image-20250206164435528.png" alt="image-20250206164435528"></p><p>后面的auto自动变化my_array中的数据</p><p><img src="https://qucheng-wuan.oss-cn-wuhan-lr.aliyuncs.com/img/image-20250206164607400.png" alt="image-20250206164607400"></p><p>上面for述句的第一部分定义<strong>被用来做范围迭代的变量</strong>，就像被声明在一般for循环的变量一样，其作用域仅只于循环的范围。而在”:”之后的第二区块，代表将<strong>被迭代的范围</strong>。</p><h3 id="C-循环语句"><a href="#C-循环语句" class="headerlink" title="C++循环语句"></a>C++循环语句</h3><h4 id="1-break"><a href="#1-break" class="headerlink" title="1.break"></a>1.break</h4><h4 id="2-continue"><a href="#2-continue" class="headerlink" title="2.continue"></a>2.continue</h4><h4 id="3-goto"><a href="#3-goto" class="headerlink" title="3.goto"></a>3.goto</h4><p>C++ 中 <strong>goto</strong> 语句的语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">goto label;</span><br><span class="line">..</span><br><span class="line">.</span><br><span class="line">label: statement;</span><br></pre></td></tr></table></figure><p>在这里，<strong>label</strong> 是识别被标记语句的标识符，可以是任何除 C++ 关键字以外的纯文本。标记语句可以是任何语句，放置在标识符和冒号（:）后边。</p><p><img src="https://qucheng-wuan.oss-cn-wuhan-lr.aliyuncs.com/img/image-20250208215048550.png" alt="image-20250208215048550"></p><h3 id="C-判断"><a href="#C-判断" class="headerlink" title="C++判断"></a>C++判断</h3><p>1.switch语句</p><ul><li>当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 <strong>break</strong> 语句为止。</li><li>当遇到 <strong>break</strong> 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。</li><li>不是每一个 case 都需要包含 <strong>break</strong>。如果 case 语句不包含 <strong>break</strong>，控制流将会 <em>继续</em> 后续的 case，直到遇到 break 为止。</li><li>一个 <strong>switch</strong> 语句可以有一个可选的 <strong>default</strong> case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 <strong>break</strong> 语句不是必需的。</li></ul><p>**注意事项：**z</p><ul><li><strong><code>break</code> 语句：</strong> 每个 <code>case</code> 语句末尾的 <code>break</code> 语句是必要的，用于跳出 <code>switch</code> 语句。如果缺少 <code>break</code>，程序将继续执行下一个 <code>case</code>，这叫做”贯穿”。</li><li><strong><code>default</code> 语句：</strong> <code>default</code> 语句是可选的，但通常在所有 <code>case</code> 都不匹配时使用，处理所有未列出的情况。</li><li><strong>表达式类型：</strong> <code>switch</code> 表达式通常是<strong>整数类型或枚举类型</strong>，浮点数和字符串类型是不可行的。</li></ul><h3 id="C-函数"><a href="#C-函数" class="headerlink" title="C++函数"></a>C++函数</h3><p>1.形式参数</p><p>形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。</p><p>当调用函数时，有三种向函数传递参数的方式：</p><table><thead><tr><th align="left">调用类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-function-call-by-value.html">传值调用</a></td><td align="left">该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-function-call-by-pointer.html">指针调用</a></td><td align="left">该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-function-call-by-reference.html">引用调用</a></td><td align="left">该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td></tr></tbody></table><p>默认情况下，C++ 使用<strong>传值调用</strong>来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的参数</p><p>2.参数的默认值</p><p><img src="https://qucheng-wuan.oss-cn-wuhan-lr.aliyuncs.com/img/image-20250207160022854.png" alt="image-20250207160022854"></p><p>注意这个sum(a) 因为b&#x3D;20在引用函数中默认了</p><h3 id="C-数组"><a href="#C-数组" class="headerlink" title="C++数组"></a>C++数组</h3><h4 id="1-多维数组"><a href="#1-多维数组" class="headerlink" title="1.多维数组"></a>1.多维数组</h4><h4 id="2-指向数组的指针"><a href="#2-指向数组的指针" class="headerlink" title="2.指向数组的指针"></a>2.指向数组的指针</h4><p>这个地方刚开始其实我不太了解现在差不多了。</p><p><strong>数组名</strong>是<u>指向数组中第一个元素的常量指针</u></p><p>使用数组名作为常量指针是合法的。因此，*（一个数组名字+2）是一种访问数组数据的合法方式。</p><p>一旦您把第一个元素的地址存储在 p 中，您就可以使用 <em>p、</em>(p+1)、*(p+2) 等来访问数组元素。</p><h4 id="3-传递数组给函数"><a href="#3-传递数组给函数" class="headerlink" title="3.传递数组给函数"></a>3.传递数组给函数</h4>]]></content>
      
      
      
        <tags>
            
            <tag> study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反思</title>
      <link href="//%E5%8F%8D%E6%80%9D/"/>
      <url>//%E5%8F%8D%E6%80%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>今天有幸和复旦的师兄在一起聊天，收获很多。其实最开始自己很犹豫自己到底应该应该从事哪个方向。其实说实话现在还没有完全的定数。不论是AI还是安全（也就是我们俗话说的红客 黑客），都是自己未来想从事的工作。从学长的话中，其实安全这一块我们只有去大厂才有机会获得一个很好的薪资，但是这一块其实对学历卡的不是特别严格，可能技术水平占主导地位吧。<strong>我暂时不了解就业市场的环境，一边依靠前辈们的教诲，一边慢慢摸索吧。</strong></p><p>对于读研这个方向其实我是坚定了这条道路的，这一点是很明确的。对于读博，听说计算机不是很好毕业（但这个还待考察） 再说，师兄说的很有道理，读完博士，如果想留校当老师其实很好，如果想去其他学校的话，有些我们可能需要去海外镀镀金再回来啥的，而且每个学期论文也是有指标的。但是，站在我的角度而言，其实这些也没什么，现在更能理解的是，<strong>行行有行行的辛苦</strong>，没人简单的一行，单听着别人说可能简单，但是我们实际上操作起来其实都是很难的，雷军就是个很好的例子。</p><p>来讲讲我个人的职业发展吧。现在我下定决心朝着保研这条路走下去了，你要清楚，保研这条路你是至少要吃三年苦的。其实现在所做的兼职，相对于之后的大厂工作，微不足道，说真的，一天时间就这么多，时间的成本其实是最高的，这个你要清楚，不用一味的追求暂时的金钱上的富足。</p><p>保研这条路呢，当然<strong>绩点很重要不能低</strong>，特别是现在的小登们都这么卷，我们需要先拿到<strong>入场券</strong>，<strong>而且一刻也不能松懈</strong>。现在确实技术不够强，<strong>一点都没必要焦虑，下定决心就好，朝着方向不断努力</strong>，这才是正道。（人家师兄都说了其实你之后回过头来看，这些都不算什么）。熬夜其实很正常，特别是你在做一些项目或者deadline学习的时候，要学会适应，但<strong>最重要的是身体健康哈，身体是革命的本钱，这个才是硬道理</strong>。</p><p>同时，比赛是少不了的。师兄CTF也没打，acm方面也没有名次。我们可以在算法方面先好好打基础，语言方面其实精通了一个，学其他的很快的，有时候想玩都可以玩玩的。机器学习的算法和数据结构的算法不是一个算法。<strong>比赛上面的综素分数是一定要打满的</strong>，到时候可以按照那个表看一看，运动啥的比赛，英语（外研社 大英赛）数学（大学生数学竞赛）想打就打，<strong>英语一定要保持学习哈</strong>。</p><p>课内知识的学习师兄说了一定都要学好些，<strong>4080那几门课程</strong>，说不定某些时候就用上了呢，到了之后一些算法的原理需要了解清楚的。大一现在先好好打好基础，比赛适量打，不需要急。大二时间少，任务重，而且要多打打比赛，大三在kaggle（ai相关的平台）上面找项目做做可以提升自己的经历。</p><p>对于师兄们来说，我现在还早呢，但其实我已经发现时间这东西过的老快了，其实要不了多久自己也要毕业了，开始工作的。看见很多人大学想家，其实你不妨想想，你已经成年了，回家少也正常，我更多的是要担当起自己的一份责任，好好努力，创造美好未来，加油吧，少年！自律才能迎接你的未来!</p>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习（Algorithm Learning)</title>
      <link href="//%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%88Algorithm-Learning)/"/>
      <url>//%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%88Algorithm-Learning)/</url>
      
        <content type="html"><![CDATA[<h1 id="算法学习（Algorithm-learning"><a href="#算法学习（Algorithm-learning" class="headerlink" title="算法学习（Algorithm learning)"></a>算法学习（Algorithm learning)</h1><p>资料：<a href="https://www.hello-algo.com/%EF%BC%88Hello%E7%AE%97%E6%B3%95%EF%BC%89">https://www.hello-algo.com/（Hello算法）</a></p><p>​           <a href="https://github.com/d2l-ai/d2l-zh%EF%BC%88%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%EF%BC%89">https://github.com/d2l-ai/d2l-zh（《动手学深度学习》）</a></p><h2 id="1-初识算法"><a href="#1-初识算法" class="headerlink" title="1.初识算法"></a>1.初识算法</h2><h3 id="1-1明确下算法和数据结构的关系："><a href="#1-1明确下算法和数据结构的关系：" class="headerlink" title="1.1明确下算法和数据结构的关系："></a>1.1明确下算法和数据结构的关系：</h3><blockquote><ul><li>数据结构是算法的基石。数据结构为算法提供了结构化存储的数据，以及操作数据的方法。</li><li>算法为数据结构注入生命力。数据结构本身仅存储数据信息，结合算法才能解决特定问题。</li><li>算法通常可以基于不同的数据结构实现，但执行效率可能相差很大，选择合适的数据结构是关键。</li></ul></blockquote><p>（之前有个误区 算法和数据结构是一个东西 其实两者是相辅相成的</p><h3 id="1-2算法误区"><a href="#1-2算法误区" class="headerlink" title="1.2算法误区:"></a>1.2算法误区:</h3><p><strong>Q</strong>：作为一名程序员，我在日常工作中从未用算法解决过问题，常用算法都被编程语言封装好了，直接用就可以了；这是否意味着我们工作中的问题还没有到达需要算法的程度？</p><p><strong>A</strong>:我认为学算法（以及其他基础科目）的意义不是在于在工作钟从零实现它，而是基于学到的知识，在解决问题时都能作出专业的反应和判断，从而提升工作的整体质量。</p><p>在工程领域，大量的问题是难以达到最优解的，许多问题只是被”差不多“解决了。问题的难度一方面取决于问题本身的性质，另一方面也取决于观测问题的人的知识储备。</p><p>人的知识越完备、经验越多，分析问题就会越深入，问题就能被解决得更优雅。</p><h2 id="2-复杂度分析"><a href="#2-复杂度分析" class="headerlink" title="2.复杂度分析"></a>2.复杂度分析</h2><h3 id="2-1算法效率评估"><a href="#2-1算法效率评估" class="headerlink" title="2.1算法效率评估"></a>2.1算法效率评估</h3><blockquote><ol><li><strong>找到问题解法</strong>：算法需要在规定的输入范围内可靠地求得问题的正确解。</li><li><strong>寻求最优解法</strong>：同一个问题可能存在多种解法，我们希望找到尽可能高效的算法。</li></ol></blockquote><h2 id="3-知识学习"><a href="#3-知识学习" class="headerlink" title="3.知识学习"></a>3.知识学习</h2><h3 id="3-1数据结构"><a href="#3-1数据结构" class="headerlink" title="3.1数据结构"></a>3.1数据结构</h3><p>链表：</p><p>单链表：邻接表–存储图</p><p>​                           –树</p><p>双链表：优化某些问题</p><p>链表其实就是一长串结点拼接而成的一个链</p><p>每一个结点有一个e[N],ne[N],也就是本结点的值和指向下一个结点的指针.  </p><p>需要注意的是head指向空结点</p><p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20250218203020629.png" alt="image-20250218203020629"></p><p>e[0]&#x3D;3,ne[0]&#x3D;1</p><p>e[1]&#x3D;5,ne[1]&#x3D;2</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法学习（Algorithm Learning) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>First blog</title>
      <link href="//First-blog/"/>
      <url>//First-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="First-blog"><a href="#First-blog" class="headerlink" title="First blog"></a>First blog</h1><p>不知为何，心血来潮，想着搭建一个博客来记录下自己的日常（或许是因为大一太摆烂的缘故吧 想记录下自己学习的总结和经验）</p><p>通过github+hexo+(butterfly主题) 形成了我的这个网站 。</p><p>感受还是蛮多的吧，刚开始看见b站上十五分钟搭成一个网站，本来以为自己很快的，没想到搭建了这么久，感觉网上有些的教程有点不靠谱（可能也是我电脑配置和能力的问题）我是参照了这位师傅的blog<a href="https://c3ngh.top/post/HexoBuild/">使用Hexo和Github Page搭建静态博客 | C3ngH’s B10g</a>来搭建我的网站，但是在域名解析这一块写的不是特别详细 大家注意看下实际所搭的云服务器对应的域名解析（选择一个自己喜欢的头），域名解析完成后需要等待一会</p><h2 id="存在dns缓存"><a href="#存在dns缓存" class="headerlink" title="存在dns缓存"></a>存在dns缓存</h2><p><img src="https://qucheng-wuan.oss-cn-wuhan-lr.aliyuncs.com/img/image-20250124181042610.png" alt="image-20250124181042610"></p><p>域名解析完成后我们就能得到一个简单的hexo界面，接着我们要选择自己喜欢的主题去润色我们自己的网站，我觉得butterfly和安知🐟都挺好看的（大家可以选择自己喜欢的去配置就好了）配置过程有些繁琐，需要我们耐心一点呐</p><h2 id="代理server连接不上"><a href="#代理server连接不上" class="headerlink" title="代理server连接不上"></a>代理server连接不上</h2><p><img src="https://qucheng-wuan.oss-cn-wuhan-lr.aliyuncs.com/img/5b3b10b70d984e8404107c599f9f717e.png" alt="5b3b10b70d984e8404107c599f9f717e"></p><p>（在这里感谢Mia师傅的解答）其实理解上来说就是梯子没有挂到终端上，</p><p><strong>我的端口是7890</strong> </p><p>所以解决方案是输入以下指令（但这个是暂时的挂到终端的选择）：</p><blockquote><p>$env:http_proxy&#x3D;”<a href="http://127.0.0.1:7890/">http://127.0.0.1:7890</a>“<br>$env:https_proxy&#x3D;”<a href="http://127.0.0.1:7890/">http://127.0.0.1:7890</a>“</p></blockquote><p>然后git clone可以正常完成和hexo三件套也能成功啦！</p><h3 id="hexo三件套前要记得挂代理"><a href="#hexo三件套前要记得挂代理" class="headerlink" title="hexo三件套前要记得挂代理"></a>hexo三件套前要记得挂代理</h3><p>好像听说还有一种steam++加速器的方法 但我不是很清楚</p><p>接下来我将会在这个网站中来更新我的blog。</p>]]></content>
      
      
      
        <tags>
            
            <tag> blog问题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
